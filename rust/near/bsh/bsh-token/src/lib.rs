//! Token BSH Contract

use bsh_periphery::BshPeriphery;
use libraries::bsh_types::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::{env, near_bindgen, setup_alloc, AccountId};
use near_sdk::{ext_contract, Promise};

/**
  @title Interface of BSHCore contract
  @dev This contract is used to handle coin transferring service
  Note: The coin of following interface can be:
  Native Coin : The native coin of this chain
  Wrapped Native Coin : A tokenized ERC1155 version of another native coin like ICX
*/
#[ext_contract]
pub trait IbshCore {
    /**
       @notice Adding another Onwer.
       @dev Caller must be an Onwer of BTP network
       @param owner    Address of a new Onwer.
    */
    fn add_owner(&mut self, owner: AccountId);

    /**
       @notice Removing an existing Owner.
       @dev Caller must be an Owner of BTP network
       @dev If only one Owner left, unable to remove the last Owner
       @param owner    Address of an Owner to be removed.
    */
    fn remove_owner(&mut self, owner: AccountId);

    /**
       @notice Checking whether one specific address has Owner role.
       @dev Caller can be ANY
       @param owner    Address needs to verify.
    */
    fn is_owner(&self, owner: AccountId) -> bool;

    /**
       @notice Get a list of current Owners
       @dev Caller can be ANY
       @return      An array of addresses of current Owners
    */
    fn get_owners(&self) -> Option<Vec<AccountId>>;

    /**
       @notice update BSH Periphery address.
       @dev Caller must be an Owner of this contract
       bshPeriphery Must be different with the existing one.
       @param bsh_periphery    BSHPeriphery contract address.
    */
    fn update_bsh_periphery(&mut self, bsh_periphery: AccountId);

    /**
       @notice update base uri.
       @dev Caller must be an Owner of this contract
       the uri must be initilized in construction.
       @param new_uri    new uri
    */
    fn update_uri(&mut self, new_uri: AccountId);

    /**
       @notice set fee ratio.
       @dev Caller must be an Owner of this contract
       The transfer fee is calculated by fee_numerator/FEE_DEMONINATOR.
       The fee_numetator should be less than FEE_DEMONINATOR
       fee_numerator is set to `10` in construction by default, which means the default fee ratio is 0.1%.
       @param fee_numerator    the fee numerator
    */
    fn set_fee_ratio(&mut self, fee_numerator: u64);

    /**
       @notice set Fixed Fee.
       @dev Caller must be an Owner
       @param fixed_fee    A new value of Fixed Fee
    */
    fn set_fixed_fee(&mut self, fixed_fee: u64);

    /**
       @notice Registers a wrapped coin and id number of a supporting coin.
       @dev Caller must be an Owner of this contract
       name Must be different with the native coin name.
       @dev 'id' of a wrapped coin is generated by using keccak256
         'id' = 0 is fixed to assign to native coin
       @param name    Coin name.
    */
    fn register(&mut self, name: String);

    /**
       @notice Return all supported coins names
       @dev
       @return   An array of strings.
    */
    fn get_coin_names(&self) -> Option<Vec<String>>;

    /**
       @notice  Return an id number of Coin whose name is the same with given coin_name.
       @dev     Return None if not found.
       @return  An ID number of coin_name.
    */
    fn get_coin_id(&self, coin_name: String) -> Option<u64>;

    /**
       @notice  Check Validity of a coin_name
       @dev     Call by BSHPeriphery contract to validate a requested coin_name
       @return  true of false
    */
    fn is_valid_coin(&self, coin_name: String) -> bool;

    /**
       @notice  Return a usable/locked/refundable balance of an account based on coin_name.
       @return  Usable balance, the balance that users are holding.
       @return  Locked balance, when users transfer the coin,
               it will be locked until getting the Service Message Response.
       @return  Refundable balance, the balance that will be refunded to users.
    */
    fn get_balance_of(&self, owner: AccountId, coin_name: String) -> (u128, u128, u128);

    /**
       @notice Return a list Balance of an account.
       @dev The order of request's coin_names must be the same with the order of return balance
       Return 0 if not found.
       @return  An array of Usable Balances
       @return  An array of Locked Balances
       @return  An array of Refundable Balances
    */
    fn get_balance_of_batch(
        &self,
        owner: AccountId,
        coin_names: Vec<String>,
    ) -> (Vec<u128>, Vec<u128>, Vec<u128>);

    /**
       @notice Return a list accumulated Fees.
       @dev Only return the asset that has Asset's value greater than 0
       @return  An array of Asset
    */
    fn get_accumulated_fees(&self) -> Vec<Asset>;

    /**
       @notice Allow users to deposit `value` native coin into a BSHCore contract.
       @dev MUST specify value
       @param to  An address that a user expects to receive an amount of tokens.
    */
    #[payable]
    fn transfer_native_coin(&mut self, to: AccountId);

    /**
       @notice Allow users to deposit an amount of wrapped native coin `coin_name` from the `env::signer_account_id` address into the BSHCore contract.
       @dev Caller must set to approve that the wrapped tokens can be transferred out of the `env::signer_account_id` account by BSHCore contract.
       It MUST revert if the balance of the holder for token `coin_name` is lower than the `value` sent.
       @param coin_name    A given name of a wrapped coin
       @param value        An amount request to transfer.
       @param to           Target BTP address.
    */
    fn transfer(&mut self, coin_name: String, value: u128, to: AccountId);

    /**
       @notice Allow users to transfer multiple coins/wrapped coins to another chain
       @dev Caller must set to approve that the wrapped tokens can be transferred out of the `env::signer_account_id` account by BSHCore contract.
       It MUST revert if the balance of the holder for token `coin_name` is lower than the `value` sent.
       In case of transferring a native coin, it also checks `value` with `values[i]`
       It MUST revert if `value` is not equal to `values[i]`
       The number of requested coins MUST be as the same as the number of requested values
       The requested coins and values MUST be matched respectively
       @param coin_names   A list of requested transferring coins/wrapped coins
       @param values       A list of requested transferring values respectively with its coin name
       @param to           Target BTP address.
    */
    #[payable]
    fn transfer_batch(&mut self, coin_names: Vec<String>, values: Vec<u128>, to: AccountId);

    /**
        @notice Reclaim the token's refundable balance by an owner.
        @dev Caller must be an owner of coin
        The amount to claim must be smaller or equal than refundable balance
        @param coin_name   A given name of coin
        @param value       An amount of re-claiming tokens
    */
    fn reclaim(&mut self, coin_name: String, value: u128);

    /**
        @notice mint the wrapped coin.
        @dev Caller must be a BSHPeriphery contract
        Invalid coin_name will have an id = 0. However, id = 0 is also dedicated to Native Coin
        Thus, BSHPeriphery will check a validity of a requested coin_name before calling
        for the coin_name indicates with id = 0, it should send the Native Coin (Example: PRA) to user account
        @param to          The account receive the minted coin
        @param coinName    Coin name
        @param value       The minted amount
    */
    fn mint(&mut self, to: AccountId, coin_name: String, value: u128);

    /**
        @notice Handle a request of Fee Gathering
        @dev    Caller must be an BSHPeriphery contract
        @param  fa    BTP Address of Fee Aggregator
    */
    fn transfer_fees(&mut self, fa: AccountId);

    /**
        @notice Handle a response of a requested service
        @dev Caller must be an BSHPeriphery contract
        @param requester   An address of originator of a requested service
        @param coin_name    A name of requested coin
        @param value       An amount to receive on a destination chain
        @param fee         An amount of charged fee
    */
    fn handle_response_service(
        &mut self,
        requester: AccountId,
        coin_name: String,
        value: u128,
        fee: u128,
        rsp_code: usize,
    );
}

/**
   @title Interface of BSHPeriphery contract
   @dev This contract is used to handle communications among BMCService and BSHCore contract
*/
#[ext_contract]
pub trait IbshPeriphery: Ibsh {
    /**
       @notice Check whether BSHPeriphery has any pending transferring requests
       @return true or false
    */
    fn has_pending_request(&self) -> bool;

    /**
       @notice Send Service Message from BSHCore contract to BMCService contract
       @dev Caller must be BSHCore only
       @param to             A network address of destination chain
       @param coin_names     A list of coin name that are requested to transfer
       @param values         A list of an amount to receive at destination chain respectively with its coin name
       @param fees           A list of an amount of charging fee respectively with its coin name
    */
    fn send_service_message(
        &mut self,
        from: AccountId,
        to: AccountId,
        coin_names: Vec<String>,
        values: Vec<u128>,
        fees: Vec<u64>,
    );

    /**
       @notice BSH handle BTP Message from BMC contract
       @dev Caller must be BMC contract only
       @param from    An originated network address of a request
       @param svc     A service name of BSHPeriphery contract
       @param sn      A serial number of a service request
       @param msg     An RLP message of a service request/service response
    */
    fn handle_btp_message(&mut self, from: AccountId, svc: String, sn: u64, msg: Vec<u8>);

    /**
       @notice BSH handle BTP Error from BMC contract
       @dev Caller must be BMC contract only
       @param svc     A service name of BSHPeriphery contract
       @param sn      A serial number of a service request
       @param code    A response code of a message (RC_OK / RC_ERR)
       @param msg     A response message
    */
    fn handle_btp_error(&mut self, src: String, svc: String, sn: u64, code: u32, msg: String);

    /**
       @notice BSH handle Gather Fee Message request from BMC contract
       @dev Caller must be BMC contract only
       @param fa     A BTP address of fee aggregator
       @param svc    A name of the service
    */
    fn handle_fee_gathering(&mut self, fa: AccountId, svc: String);
}

type BatchedBalance = (Vec<u128>, Vec<u128>, Vec<u128>);

setup_alloc!();

/**
    @title BSHToken contract
    @dev This contract is used to handle coin transferring service
    Note: The coin of following contract can be:
    Native Coin : The native coin of this chain
    Wrapped Native Coin : A tokenized ERC1155 version of another native coin like ICX
*/
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct BshToken {
    owners: UnorderedMap<String, bool>,
    list_of_owners: Vec<String>,
    bsh_periphery: BshPeriphery,
    uri: AccountId,
    aggregation_fee: UnorderedMap<String, u128>,
    // mapping from account ID to coin balances
    // first string refers to account ID
    // second string refers to coin name
    coin_balances: UnorderedMap<String, UnorderedMap<String, Balance>>,
    // mapping from coin ID to account balances
    account_balances: UnorderedMap<u64, UnorderedMap<String, u128>>,
    // map of coin name to coin ID
    coins: UnorderedMap<String, u64>,
    coin_names: Vec<String>,
    charged_coins: Vec<String>,
    charged_amounts: Vec<u128>,
    pub fee_numerator: u128,
    pub fixed_fee: u128,
}

impl Default for BshToken {
    fn default() -> Self {
        Self {
            owners: UnorderedMap::new(BshStorageKey::BshToken),
            list_of_owners: vec![],
            bsh_periphery: BshPeriphery::default(),
            aggregation_fee: UnorderedMap::new(BshStorageKey::BshToken),
            uri: "".to_string(),
            coin_balances: UnorderedMap::new(BshStorageKey::BshToken),
            account_balances: UnorderedMap::new(BshStorageKey::BshToken),
            coins: UnorderedMap::new(BshStorageKey::BshToken),
            coin_names: vec![],
            charged_coins: vec![],
            charged_amounts: vec![],
            fee_numerator: 0,
            fixed_fee: 0,
        }
    }
}

#[near_bindgen]
impl BshToken {
    pub const FEE_DENOMINATOR: u128 = u128::pow(10, 4);
    pub const RC_OK: usize = 0;
    pub const RC_ERR: usize = 1;

    #[init]
    pub fn new(
        uri: AccountId,
        native_coin_name: String,
        fee_numerator: u128,
        fixed_fee: u128,
    ) -> Self {
        let mut owners: UnorderedMap<String, bool> = UnorderedMap::new(BshStorageKey::BshToken);
        let list_of_owners = vec![env::signer_account_id()];
        let mut coins: UnorderedMap<String, u64> = UnorderedMap::new(BshStorageKey::BshToken);
        let coin_names = vec![native_coin_name.clone()];

        let _ = owners.insert(&env::signer_account_id(), &true);
        let _ = coins.insert(&native_coin_name, &0);

        let bsh_event = BshEvents::SetOwnership {
            promoter: env::predecessor_account_id(),
            new_owner: env::signer_account_id(),
        };
        let bsh_event = bsh_event
            .try_to_vec()
            .expect("Failed to serialize bsh event");
        env::log(&bsh_event);

        Self {
            owners,
            list_of_owners,
            bsh_periphery: BshPeriphery::default(),
            aggregation_fee: UnorderedMap::new(BshStorageKey::BshToken),
            uri,
            coin_balances: UnorderedMap::new(BshStorageKey::BshToken),
            account_balances: UnorderedMap::new(BshStorageKey::BshToken),
            coins,
            coin_names,
            charged_coins: vec![],
            charged_amounts: vec![],
            fee_numerator,
            fixed_fee,
        }
    }

    pub fn deploy_bsh_token_contract(&self, account_id: AccountId, amount: u128) {
        let promise_idx = env::promise_batch_create(&account_id);
        env::promise_batch_action_create_account(promise_idx);
        env::promise_batch_action_transfer(promise_idx, amount);
        env::promise_batch_action_add_key_with_full_access(
            promise_idx,
            &env::signer_account_pk(),
            0,
        );
        // let code: &[u8] = include_bytes!("../rust/near/token-bsh/res/token-bsh.wasm");
        // FIXME^ uncomment once contract is compiled to WASM
        let code: Vec<u8> = vec![];
        env::promise_batch_action_deploy_contract(promise_idx, &code);
    }

    /**
        @notice Adding another Owner.
        @dev Caller must be an Owner of BTP network
        @param owner    Address of a new Owner.
    */
    pub fn add_owner(&mut self, owner: AccountId) -> Result<(), &str> {
        if !self
            .owners
            .get(&env::signer_account_id())
            .expect("Error in retrieving account info")
        {
            return Err("BshToken: Unauthorized");
        }
        if self
            .owners
            .get(&owner)
            .expect("Error in retrieving owner info")
        {
            return Err("ExistedOwner");
        }
        let _ = self.owners.insert(&owner, &true);
        self.list_of_owners.push(owner.clone());
        let bsh_event = BshEvents::SetOwnership {
            promoter: env::signer_account_id(),
            new_owner: owner,
        };
        let bsh_event = bsh_event
            .try_to_vec()
            .expect("Failed to serialize bsh event");
        env::log(&bsh_event);
        Ok(())
    }

    /**
        @notice Removing an existing Owner.
        @dev Caller must be an Owner of BTP network
        @dev If only one Owner left, unable to remove the last Owner
        @param owner    Address of an Owner to be removed.
    */
    pub fn remove_owner(&mut self, owner: AccountId) -> Result<(), &str> {
        if !self
            .owners
            .get(&env::signer_account_id())
            .expect("Error in retrieving account info")
        {
            return Err("BshToken: Unauthorized");
        }
        if self.list_of_owners.len() <= 1 {
            return Err("Unable to remove last owner");
        }
        if !self
            .owners
            .get(&owner)
            .expect("Error in retrieving owner info")
        {
            return Err("Owner not found");
        }

        let _ = self.owners.remove(&owner);
        self.remove(owner.clone());
        let bsh_event = BshEvents::RemoveOwnership {
            remover: env::signer_account_id(),
            former_owner: owner,
        };
        let bsh_event = bsh_event
            .try_to_vec()
            .expect("Failed to serialize bsh event");
        env::log(&bsh_event);
        Ok(())
    }

    fn remove(&mut self, addr: AccountId) {
        for i in 0..self.list_of_owners.len() {
            if self.list_of_owners[i] == addr {
                self.list_of_owners[i] = self.list_of_owners[self.list_of_owners.len() - 1].clone();
                let _ = self.list_of_owners.pop();
                break;
            }
        }
    }

    /**
        @notice Checking whether one specific address has Owner role.
        @dev Caller can be ANY
        @param owner    Address needs to verify.
    */
    pub fn is_owner(&self, owner: AccountId) -> bool {
        self.owners.get(&owner).expect("Owner lookup error")
    }

    /**
        @notice Get a list of current Owners
        @dev Caller can be ANY
        @return      An array of addresses of current Owners
    */
    pub fn get_owners(&self) -> &Vec<String> {
        &self.list_of_owners
    }

    /**
        @notice update base uri.
        @dev Caller must be an Owner of this contract
        the uri must be initilized in construction.
        @param _newURI    new uri
    */
    pub fn update_uri(&mut self, new_uri: AccountId) -> Result<(), &str> {
        if !self
            .owners
            .get(&env::signer_account_id())
            .expect("Error in retrieving account info")
        {
            return Err("BshToken: Unauthorized");
        }
        self.uri = new_uri;

        Ok(())
    }

    /**
        @notice set fee ratio.
        @dev Caller must be an Owner of this contract
        The transfer fee is calculated by fee_numerator/FEE_DEMONINATOR.
        The fee_numetator should be less than FEE_DEMONINATOR
        fee_numerator is set to `10` in construction by default, which means the default fee ratio is 0.1%.
        @param fee_numerator    the fee numerator
    */
    pub fn set_fee_ratio(&mut self, fee_numerator: u128) -> Result<(), &str> {
        if !self
            .owners
            .get(&env::signer_account_id())
            .expect("Error in retrieving account info")
        {
            return Err("BshToken: Unauthorized");
        }
        if fee_numerator > Self::FEE_DENOMINATOR {
            return Err("Invalid setting");
        }
        self.fee_numerator = fee_numerator;
        Ok(())
    }

    /**
        @notice set Fixed Fee.
        @dev Caller must be an Owner
        @param fixed_fee    A new value of Fixed Fee
    */
    pub fn set_fixed_fee(&mut self, fixed_fee: u128) -> Result<(), &str> {
        if !self
            .owners
            .get(&env::signer_account_id())
            .expect("Error in retrieving account info")
        {
            return Err("BshToken: Unauthorized");
        }
        self.fixed_fee = fixed_fee;
        Ok(())
    }

    /**
        @notice Registers a wrapped coin and id number of a supporting coin.
        @dev Caller must be an Owner of this contract
        name Must be different with the native coin name.
        @dev 'id' of a wrapped coin is generated by using keccak256
         'id' = 0 is fixed to assign to native coin
        @param name    Coin name.
    */
    pub fn register(&mut self, name: String) -> Result<(), &str> {
        if !self
            .owners
            .get(&env::signer_account_id())
            .expect("Error in retrieving account info")
        {
            return Err("BshToken: Unauthorized");
        }
        if self.coins.get(&name).expect("Error in coin name lookup") != 0 {
            return Err("ExistToken");
        }
        let id = u64::deserialize(&mut env::keccak256(name.as_bytes()).as_slice())
            .expect("Error in conversion");
        let _ = self.coins.insert(&name, &id);
        self.coin_names.push(name);
        Ok(())
    }

    /**
        @notice Return all supported coins names
        @dev
        @return names   An array of strings.
    */
    pub fn get_coin_names(&self) -> &Vec<String> {
        &self.coin_names
    }

    /**
        @notice Return all supported coins names
        @dev
        @return   An array of strings.
    */
    pub fn get_coin_id(&self, coin_name: String) -> u64 {
        self.coins.get(&coin_name).expect("Failed to get coin ID")
    }

    /**
        @notice  Check Validity of a coin_name
        @dev     Call by BSHPeriphery contract to validate a requested coin_name
        @return  true of false
    */
    pub fn is_valid_coin(&self, coin_name: String) -> bool {
        self.coins
            .get(&coin_name)
            .expect("Failed to retrieve coin ID")
            != 0
            || coin_name != self.coin_names[0]
    }

    /**
        @notice  Return a usable/locked/refundable balance of an account based on coin_name.
        @return  Usable balance, the balance that users are holding.
        @return  Locked balance, when users transfer the coin,
                 it will be locked until getting the Service Message Response.
        @return  Refundable balance, the balance that will be refunded to users.
    */
    pub fn get_balance_of(&self, owner: AccountId, coin_name: String) -> (u128, u128, u128) {
        let (locked_balance, refundable_balance) =
            self.get_coin_balances(owner.clone(), coin_name.clone());

        if coin_name == self.coin_names[0] {
            return (env::account_balance(), locked_balance, refundable_balance);
        }
        let coin_id = self
            .coins
            .get(&coin_name)
            .expect("Error in coin name lookup");
        (
            self.balance_of(owner, coin_id)
                .expect("Failed to get balance"),
            locked_balance,
            refundable_balance,
        )
    }

    /**
        @notice Return a list Balance of an account.
        @dev The order of request's coin_names must be the same with the order of return balance
        Return 0 if not found.
        @return  An array of Usable Balances
        @return  An array of Locked Balances
        @return  An array of Refundable Balances
    */
    pub fn get_balance_of_batch(&self, owner: AccountId, coin_names: &[String]) -> BatchedBalance {
        let mut usable_balances: Vec<u128> = Vec::with_capacity(coin_names.len());
        let mut locked_balances: Vec<u128> = Vec::with_capacity(coin_names.len());
        let mut refundable_balances: Vec<u128> = Vec::with_capacity(coin_names.len());
        for coin in coin_names {
            let owner = owner.clone();
            let (usable_bal, locked_bal, refundable_bal) =
                self.get_balance_of(owner, coin.to_string());

            usable_balances.push(usable_bal);
            locked_balances.push(locked_bal);
            refundable_balances.push(refundable_bal);
        }
        (usable_balances, locked_balances, refundable_balances)
    }

    /**
        @notice Return a list accumulated Fees.
        @dev Only return the asset that has Asset's value greater than 0
        @return  An array of Asset
    */
    pub fn get_accumulated_fees(&self) -> Vec<Asset> {
        let mut accumulated_fees: Vec<Asset> = Vec::with_capacity(self.coin_names.len());
        for i in 0..self.coin_names.len() {
            let asset = Asset {
                coin_name: self.coin_names[i].clone(),
                value: self
                    .aggregation_fee
                    .get(&self.coin_names[i])
                    .expect("Failed to get value"),
            };
            accumulated_fees.push(asset);
        }
        accumulated_fees
    }

    /**
        @notice Allow users to deposit `value` native coin into a BSHCore contract.
        @dev MUST specify value
        @param to  An address that a user expects to receive an amount of tokens.
    */
    #[payable]
    pub fn transfer_native_coin(&mut self, to: AccountId) {
        //  Aggregation Fee will be charged on BSH Contract
        //  A new charging fee has been proposed. `fixed_fee` is introduced
        //  charge_amt = fixed_fee + value * fee_numerator / FEE_DENOMINATOR
        //  Thus, it's likely that charge_amt is always greater than 0
        //  require(charge_amt > 0) can be omitted
        //  If value less than charge_amt, it likely fails when calculating
        //  amount = value - chargeAmt
        let charge_amt = env::attached_deposit()
            .checked_mul(self.fee_numerator)
            .expect("Error in checked multiplication")
            .checked_div(Self::FEE_DENOMINATOR)
            .expect("Error in checked division")
            .checked_add(self.fixed_fee)
            .expect("Error in checked addition");
        self.send_service_message(
            env::signer_account_id(),
            to,
            self.coin_names[0].clone(),
            env::attached_deposit(),
            charge_amt,
        )
        .expect("Failed to send message");
    }

    /**
        @notice Allow users to deposit an amount of wrapped native coin `coin_name` from the `env::signer_account_id` address into the BSHCore contract.
        @dev Caller must set to approve that the wrapped tokens can be transferred out of the `env::signer_account_id` account by BSHCore contract.
        It MUST revert if the balance of the holder for token `coin_name` is lower than the `value` sent.
        @param coin_name    A given name of a wrapped coin
        @param value        An amount request to transfer.
        @param to           Target BTP address.
    */
    pub fn transfer(&mut self, coin_name: String, value: u128, to: AccountId) -> Result<(), &str> {
        if self.coins.get(&coin_name).expect("Error in coin lookup") == 0 {
            return Err("UnregisteredCoin");
        }
        let charge_amt = env::attached_deposit()
            .checked_mul(self.fee_numerator)
            .expect("Error in checked multiplication")
            .checked_div(Self::FEE_DENOMINATOR)
            .expect("Error in checked division")
            .checked_add(self.fixed_fee)
            .expect("Error in checked addition");

        if charge_amt == 0 {
            return Err("Invalid amount");
        }
        self.safe_transfer_from(
            env::signer_account_id(),
            env::current_account_id(),
            coin_name,
            value,
        )
        .expect("Failed to do safe transfer");
        self.send_service_message(
            env::signer_account_id(),
            to,
            self.coin_names[0].clone(),
            env::attached_deposit(),
            charge_amt,
        )
        .expect("Failed to send service message");
        Ok(())
    }

    /**
       @notice Allow users to transfer multiple coins/wrapped coins to another chain
       @dev Caller must set to approve that the wrapped tokens can be transferred out of the `env::signer_account_id` account by BSHCore contract.
       It MUST revert if the balance of the holder for token `coin_name` is lower than the `value` sent.
       In case of transferring a native coin, it also checks `value` with `values[i]`
       It MUST revert if `value` is not equal to `values[i]`
       The number of requested coins MUST be as the same as the number of requested values
       The requested coins and values MUST be matched respectively
       @param coin_names   A list of requested transferring coins/wrapped coins
       @param values       A list of requested transferring values respectively with its coin name
       @param to           Target BTP address.
    */
    #[payable]
    pub fn transfer_batch(
        &mut self,
        coin_names: Vec<String>,
        values: Vec<u128>,
        to: AccountId,
    ) -> Result<(), &str> {
        if coin_names.len() != values.len() {
            return Err("Invalid request");
        }
        let size = coin_names.len();
        let mut amounts: Vec<u128> = Vec::with_capacity(size);
        let mut charge_amts: Vec<u128> = Vec::with_capacity(size);
        for i in 0..size {
            charge_amts.push(
                values[i]
                    .checked_mul(self.fee_numerator)
                    .expect("Failed to safely multiply")
                    .checked_div(Self::FEE_DENOMINATOR)
                    .expect("Failed to safely divide"),
            );
            if coin_names[i] == self.coin_names[i] {
                if charge_amts[i] == 0 && values[i] != env::attached_deposit() {
                    return Err("Invalid amount");
                }
            } else {
                let id = self
                    .coins
                    .get(&coin_names[i])
                    .expect("Failed to retrieve coin ID");
                if id == 0 {
                    return Err("Unregistered coin");
                }
                if charge_amts[i] == 0 {
                    return Err("Invalid amount");
                }
                self.safe_transfer_from(
                    env::signer_account_id(),
                    env::current_account_id(),
                    coin_names[i].clone(),
                    values[i],
                )
                .expect("Failed to do safe transfer");
            }
            amounts.push(
                values[i]
                    .checked_sub(charge_amts[i])
                    .expect("Failed to safely subtract"),
            );
            self.lock_balance(env::signer_account_id(), coin_names[i].clone(), values[i])
                .expect("Failed to lock balance");
        }
        let _ = self.bsh_periphery.send_service_message(
            env::signer_account_id(),
            to,
            coin_names.to_vec(),
            amounts,
            charge_amts,
        );
        Ok(())
    }

    /// Allow users to deposit an amount of wrapped native coin into the contract.
    /// Caller must set condition to approve transfer of wrapped tokens out of source account.
    /// Revert if balance of source account is less than specified transfer amount.
    pub fn transfer_to_contract(
        &mut self,
        coin_name: String,
        value: u128,
        to: AccountId,
    ) -> Result<(), &str> {
        if self
            .coins
            .get(&coin_name)
            .expect("Error in retrieving coin ID")
            == 0
        {
            return Err("Unregistered coin");
        }
        let charge_amt = value
            .checked_mul(self.fee_numerator)
            .expect("Failed to safely multiply")
            .checked_div(Self::FEE_DENOMINATOR)
            .expect("Failed to safely divide");
        if charge_amt == 0 {
            return Err("Invalid amount");
        }
        Promise::new(to.clone()).create_account().transfer(value);
        self.send_service_message(env::signer_account_id(), to, coin_name, value, charge_amt)
            .expect("Failed to send service message");
        Ok(())
    }

    /**
        @notice Reclaim the token's refundable balance by an owner.
        @dev Caller must be an owner of coin
        The amount to claim must be smaller or equal than refundable balance
        @param coin_name   A given name of coin
        @param value       An amount of re-claiming tokens
    */
    pub fn reclaim(&mut self, coin_name: String, value: u128) -> Result<(), &str> {
        let (locked_balance, refundable_balance) =
            self.get_coin_balances(env::signer_account_id(), coin_name.clone());
        if refundable_balance < value {
            return Err("Imbalance");
        }
        let balance = Balance {
            locked_balance,
            refundable_balance,
        };
        let _ = balance
            .refundable_balance
            .checked_sub(value)
            .expect("Failed to safely subtract");

        let mut bals = self
            .coin_balances
            .get(&env::signer_account_id())
            .expect("Error in account lookup");
        let _ = bals.insert(&coin_name, &balance);

        let _ = self.coin_balances.insert(&coin_name, &bals);
        self.refund(env::signer_account_id(), coin_name, value)
            .expect("Failed to refund");
        Ok(())
    }

    /// Return coin for the failed transfer.
    /// Caller must be itself.
    pub fn refund(&mut self, to: AccountId, coin_name: String, value: u128) -> Result<(), &str> {
        if env::signer_account_id() != env::current_account_id() {
            return Err("Unauthorized");
        }
        let id = self.coins.get(&coin_name).expect("Failed to get coin ID");
        if id == 0 {
            self.transfer_to_contract(coin_name, value, to.clone())
                .expect("Failed to transfer amount to the contract");
            return Ok(());
        } else {
            self.safe_transfer_from(env::current_account_id(), to, coin_name, value)
                .expect("Failed to do safe transfer");
        }
        Ok(())
    }

    /**
        @notice mint the wrapped coin.
        @dev Caller must be a BSHPeriphery contract
        Invalid coin_name will have an id = 0. However, id = 0 is also dedicated to Native Coin
        Thus, BSHPeriphery will check a validity of a requested coin_name before calling
        for the coin_name indicates with id = 0, it should send the Native Coin (Example: PRA) to user account
        @param to          The account receive the minted coin
        @param coinName    Coin name
        @param value       The minted amount
    */
    pub fn mint(&mut self, to: AccountId, coin_name: String, value: u128) -> Result<(), &str> {
        let bsh_periphery_addr = self.bsh_periphery.get_contract_address();
        if env::signer_account_id() != bsh_periphery_addr {
            return Err("Unauthorized");
        }
        let id = self.coins.get(&coin_name).expect("Failed to get coin ID");
        if id == 0 {
            self.transfer_to_contract(coin_name, value, to)
                .expect("Failed to transfer amount to the contract");
        } else {
            let mut coin = self
                .account_balances
                .get(&id)
                .expect("Failed to get coin info");
            let balance = coin.get(&coin_name).expect("Error in retrieving balance");
            let _ = coin.insert(&coin_name, &(balance + value));

            let _ = self.account_balances.insert(&id, &coin);
        }
        Ok(())
    }

    /**
        @notice Handle a response of a requested service
        @dev Caller must be an BSHPeriphery contract
        @param requester    An address of originator of a requested service
        @param coin_name    A name of requested coin
        @param value       An amount to receive on a destination chain
        @param fee         An amount of charged fee
    */
    pub fn handle_response_service(
        &mut self,
        requester: AccountId,
        coin_name: String,
        value: u128,
        fee: u128,
        rsp_code: usize,
    ) -> Result<(), &str> {
        let bsh_periphery_addr = self.bsh_periphery.get_contract_address();
        if env::signer_account_id() != bsh_periphery_addr {
            return Err("Unauthorized");
        }
        if requester == env::current_account_id() {
            if rsp_code == Self::RC_ERR {
                let agg_fee = self
                    .aggregation_fee
                    .get(&coin_name)
                    .expect("Error in lookup");
                let _ = self.aggregation_fee.insert(
                    &coin_name,
                    &(agg_fee.checked_add(value).expect("Failed to safely add")),
                );
            }
            return Ok(());
        }
        let amount = value.checked_add(fee).expect("Failed to safely add");

        let (locked_balance, refundable_balance) =
            self.get_coin_balances(requester.clone(), coin_name.clone());

        let balance = Balance {
            locked_balance,
            refundable_balance,
        };
        let _ = balance
            .locked_balance
            .checked_sub(amount)
            .expect("Failed to safely subtract");
        let mut coin = self
            .coin_balances
            .get(&requester)
            .expect("Error in account lookup");
        let _ = coin.insert(&coin_name, &balance);
        let _ = self.coin_balances.insert(&requester, &coin);

        if rsp_code == Self::RC_ERR {
            if self
                .refund(requester.clone(), coin_name.clone(), amount)
                .is_err()
            {
                let _ = balance
                    .refundable_balance
                    .checked_add(amount)
                    .expect("Failed to safely add");
                let _ = coin.insert(&coin_name, &balance);
                let _ = self.coin_balances.insert(&requester, &coin);
            }
        } else if rsp_code == Self::RC_OK {
            let id = self
                .coins
                .get(&coin_name)
                .expect("Failed to retrieve coin ID");
            if id != 0 {
                self.burn(env::signer_account_id(), coin_name.clone(), value)
                    .expect("Failed to burn");
            }
            let agg_fee = self
                .aggregation_fee
                .get(&coin_name)
                .expect("Error in lookup");
            let _ = self.aggregation_fee.insert(
                &coin_name,
                &(agg_fee.checked_add(fee).expect("Failed to safely add")),
            );
        }

        Ok(())
    }

    /// Handle a request of fee gathering.
    /// Caller must be BSHPeriphery contract.
    /// `fa`: BTP address of fee aggregator.
    pub fn transfer_fees(&mut self, fa: AccountId) -> Result<(), &str> {
        for i in 0..self.coin_names.len() {
            let aggr_fee = self
                .aggregation_fee
                .get(&self.coin_names[i])
                .expect("Failed to get agrregation fee");
            if aggr_fee != 0 {
                self.charged_coins.push(self.coin_names[i].clone());
                self.charged_amounts.push(aggr_fee);
                let _ = self.aggregation_fee.remove(&self.coin_names[i]);
            }
        }
        let charged_fees: Vec<u128> = Vec::with_capacity(self.charged_coins.len());
        self.bsh_periphery
            .send_service_message(
                env::current_account_id(),
                fa,
                self.charged_coins.clone(),
                self.charged_amounts.clone(),
                charged_fees,
            )
            .expect("Failed to send service message");
        self.charged_coins.clear();
        self.charged_amounts.clear();
        Ok(())
    }

    /**
       @notice This private function handles overlapping procedure before sending a service message to BSHPeriphery
       @param from             An address of a Requester
       @param to               BTP address of of Receiver on another chain
       @param coin_name        A given name of a requested coin
       @param value            A requested amount to transfer from a Requester (include fee)
       @param charge_amt       An amount being charged for this request
    */
    fn send_service_message(
        &mut self,
        from: AccountId,
        to: AccountId,
        coin_name: String,
        value: u128,
        charge_amt: u128,
    ) -> Result<(), &str> {
        self.lock_balance(from.clone(), coin_name.clone(), value)
            .expect("Failed to lock balance");
        let coins = vec![coin_name];
        let amounts = vec![value
            .checked_sub(charge_amt)
            .expect("Failed to safely subtract")];
        let fees = vec![charge_amt];
        let _ = self
            .bsh_periphery
            .send_service_message(from, to, coins, amounts, fees);
        Ok(())
    }

    fn safe_transfer_from(
        &mut self,
        from: AccountId,
        to: AccountId,
        coin_name: String,
        amount: u128,
    ) -> Result<(), &str> {
        let coin_id = self
            .coins
            .get(&coin_name)
            .expect("Error in coin name lookup");
        let from_balance = self
            .account_balances
            .get(&coin_id)
            .expect("Error in coin ID lookup")
            .get(&from)
            .expect("Error in account lookup");
        let to_balance = self
            .account_balances
            .get(&coin_id)
            .expect("Error in coin ID lookup")
            .get(&to)
            .expect("Error in account lookup");

        if from_balance < amount {
            return Err("Insufficient balance for transfer");
        }

        let mut bals = self
            .account_balances
            .get(&coin_id)
            .expect("Error in coin ID lookup");
        let _ = bals.insert(&from, &(from_balance - amount));
        let _ = bals.insert(&to, &(to_balance + amount));
        let _ = self.account_balances.insert(&coin_id, &bals);
        Ok(())
    }

    fn lock_balance(
        &mut self,
        account: AccountId,
        coin_name: String,
        value: u128,
    ) -> Result<(), &str> {
        let (locked_balance, refundable_balance) =
            self.get_coin_balances(account.clone(), coin_name.clone());

        let balance = Balance {
            locked_balance,
            refundable_balance,
        };
        let _ = balance
            .locked_balance
            .checked_add(value)
            .expect("Failed to safely add");
        let mut coin = self
            .coin_balances
            .get(&account)
            .expect("Error in account lookup");
        let _ = coin.insert(&coin_name, &balance);
        let _ = self.coin_balances.insert(&account, &coin);
        Ok(())
    }

    fn get_coin_balances(&self, addr: AccountId, coin_name: String) -> (u128, u128) {
        let locked_balance = self
            .coin_balances
            .get(&addr)
            .expect("Error in owner lookup")
            .get(&coin_name)
            .expect("Error in coin name lookup")
            .locked_balance;
        let refundable_balance = self
            .coin_balances
            .get(&addr)
            .expect("Error in owner lookup")
            .get(&coin_name)
            .expect("Error in coin name lookup")
            .refundable_balance;
        (locked_balance, refundable_balance)
    }

    fn balance_of(&self, account: AccountId, coin_id: u64) -> Result<u128, &str> {
        if account == env::predecessor_account_id() {
            return Err("Balance query for the zero address");
        }
        Ok(self
            .account_balances
            .get(&coin_id)
            .expect("Error in coin ID lookup")
            .get(&account)
            .expect("Error in account lookup"))
    }

    fn burn(&mut self, account: AccountId, coin_name: String, amount: u128) -> Result<(), &str> {
        if account == env::predecessor_account_id() {
            return Err("Burn from zero address not allowed");
        }
        let id = self
            .coins
            .get(&coin_name)
            .expect("Failed to retrieve coin ID");
        let mut coin = self
            .account_balances
            .get(&id)
            .expect("Error in account lookup");
        let account_balance = coin.get(&coin_name).expect("Error in coin name lookup");
        if account_balance < amount {
            return Err("Burn amount exceeds balance");
        }
        let _ = coin.insert(&coin_name, &(account_balance - amount));
        let _ = self.account_balances.insert(&id, &coin);
        Ok(())
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, MockedBlockchain, VMContext};
    use std::convert::TryInto;

    fn get_context(is_view: bool) -> VMContext {
        VMContextBuilder::new()
            .signer_account_id("bob_near".try_into().expect("Failed to convert"))
            .is_view(is_view)
            .build()
    }

    #[test]
    fn test_get_owners() {
        testing_env!(get_context(false));
        let mut token_bsh = BshToken::default();
        assert!(token_bsh.list_of_owners.is_empty());
        token_bsh
            .list_of_owners
            .push("btp://0x1.near/cx87ed9048b594b95199f326fc76e76a9d33dd665b".to_string());
        assert_eq!(token_bsh.get_owners().len(), 1);
    }

    #[test]
    fn test_register() {
        testing_env!(get_context(false));
        let mut token_bsh = BshToken::default();
        assert!(token_bsh.coin_names.is_empty());
        assert!(token_bsh.coins.is_empty());

        let coin_name = "kobby";
        token_bsh.coin_names.push(coin_name.to_string());
        assert_eq!(&token_bsh.coin_names[0], "kobby");

        let coin_name_bytes = env::keccak256(coin_name.as_bytes());
        let id = u64::deserialize(&mut coin_name_bytes.as_slice()).expect("Err");
        let _ = token_bsh.coins.insert(&coin_name.to_string(), &id);
    }

    #[test]
    fn test_seserialize_and_deserialize_token_bsh() {
        testing_env!(get_context(false));
        let token_bsh = BshToken::default();
        let coded_bsh = token_bsh
            .try_to_vec()
            .expect("Failed to serialize bsh event");
        let decoded_bsh = BshToken::deserialize(&mut coded_bsh.as_slice()).expect("Err");
        assert_eq!(
            token_bsh.fee_numerator, decoded_bsh.fee_numerator,
            "Data mismatch"
        );
    }
}
